package main

import (
	"context"
	"github.com/danielgtaylor/huma/v2"
	"github.com/danielgtaylor/huma/v2/adapters/humachi"
	"github.com/dresswithpockets/openstats/app/auth"
	"github.com/dresswithpockets/openstats/app/db"
	"github.com/dresswithpockets/openstats/app/internal"
	"github.com/dresswithpockets/openstats/app/users"
	"github.com/dresswithpockets/openstats/app/validation"
	"github.com/go-chi/chi/v5"
	"github.com/rs/cors"
	"log"
	"net/http"
	"reflect"
)

func HandlerTODO(ctx context.Context, input *struct{}) (*struct{}, error) {
	panic("HandlerTODO")
}

func main() {
	if err := db.SetupDB(context.Background()); err != nil {
		log.Fatal(err)
	}

	if err := validation.SetupValidations(); err != nil {
		log.Fatal(err)
	}

	// we need a root admin user in order to do admin operations. The root user is also the only user that can add
	// other admins
	auth.AddRootAdminUser(context.Background())

	router := chi.NewMux()
	router.Use(cors.New(cors.Options{
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowCredentials: true,
	}).Handler)
	// TODO: CSRF middleware
	// TODO: rate limit middleware

	config := huma.DefaultConfig("openstats API", "1.0.0")
	config.Info = &huma.Info{
		Title:       "openstats API",
		Description: "The public openstats API",
		Contact: &huma.Contact{
			Name: "dresswithpockets",
			URL:  "https://github.com/dresswithpockets",
		},
		License: &huma.License{
			Name:       "GPL General Public License v3",
			Identifier: "GPL-3.0-or-later",
			URL:        "https://spdx.org/licenses/GPL-3.0-or-later.html",
		},
		Version: "v1.0.0",
	}
	config.Components.SecuritySchemes = map[string]*huma.SecurityScheme{
		"SessionCookie": {
			Type:        "apiKey",
			In:          "cookie",
			Description: "A session cookie is used to store the user's session token. See Authentication for usage.",
			Name:        auth.SessionCookieName,
		},
		"GameToken": {
			Type:         "http",
			Scheme:       "bearer",
			BearerFormat: "RID",
			Description:  "A secret token generated by a user, to authenticate a game to track game stats, sessions, and achievements for them.",
		},
		"GameSession": {
			Type:         "http",
			Scheme:       "bearer",
			BearerFormat: "JWT",
			Description:  "A JWT created when a Game Session is started, used to authenticate all Game Session actions.",
		},
	}

	huma.SchemaFromType(config.OpenAPI.Components.Schemas, reflect.TypeFor[validation.LookupID]())

	api := humachi.New(router, config)

	type ReadyResponse struct{ OK bool }
	huma.Register(api, huma.Operation{
		OperationID: "readyz",
		Method:      http.MethodGet,
		Path:        "/readyz",
		Summary:     "Get Readiness",
		Description: "Get whether or not the API is ready to process requests",
		Tags:        []string{"Health Check"},
	}, func(ctx context.Context, _ *struct{}) (*ReadyResponse, error) {
		return &ReadyResponse{OK: true}, nil
	})

	//auth.RegisterRoutes(api)
	users.RegisterRoutes(api)
	internal.RegisterRoutes(api)

	// TODO: permissions verification mechanism
	//  Actions:
	//   Create
	//   Read
	//   Update
	//   Delete

	/*
		TODO: example resource with variable authorization requirements:
			- Root can Create, Read, Update, Delete any non-Root User
			- Admins can Create, Read, Update, Delete any non-Admin User
			- Anyone can Read any User
			- A User may Update their own User

		CanRead() = true
		CanCreate() = (IsRoot(CurrentUser) and IsNotRoot(CreatedUser)) or (IsAdmin(CurrentUser) and IsNotAdmin(CreatedUser))
		CanUpdate() = (IsRoot(CurrentUser) and IsNotRoot(UpdatedUser)) or (IsAdmin(CurrentUser) and IsNotAdmin(UpdatedUser)) or (CurrentUser == UpdatedUser)
		CanDelete() = (IsRoot(CurrentUser) and IsNotRoot(DeletedUser)) or (IsAdmin(CurrentUser) and IsNotAdmin(DeletedUser))
	*/

	// TODO:
	//  /users/v1 - query & filter all users
	//  /users/v1/{slug} - CRUD information about the user (slug, UUID, display name)
	//  /users/v1/{slug}/developers - query & filter developers the user is a member of
	//  /users/v1/{slug}/games - query & filter games with sessions/stats/achievements for the user
	//  /users/v1/{slug}/sessions - query & filter play sessions for the user
	//  /users/v1/{slug}/achievements - query & filter achievement progress for the user
	//  /users/v1/{slug}/tokens
	//  /users/v1/{slug}/tokens/{slug}

	// TODO:
	//  /developers/v1
	//  /developers/v1/{slug}/members
	//  /developers/v1/{slug}/games
	//  /developers/v1/{slug}/games/{slug}
	//  /developers/v1/{slug}/games/{slug}/achievements
	//  /developers/v1/{slug}/games/{slug}/achievements/{slug}

	if err := http.ListenAndServe(":3000", router); err != nil {
		log.Fatal(err)
	}

	//ErrorHandler: func(c *fiber.Ctx, err error) error {
	//	var validationErr *ValidationError
	//	if errors.As(err, &validationErr) {
	//		var fieldErrors map[string][]string
	//		for _, fieldError := range validationErr.Errors {
	//			detail := GetValidationDetail(fieldError.Field)
	//			fieldErrors[fieldError.Field] = append(fieldErrors[fieldError.Field], detail)
	//		}
	//
	//		c.Status(fiber.StatusBadRequest)
	//		return c.JSON(problems.Validation("", fieldErrors))
	//	}
	//
	//	var conflictErr *ConflictError
	//	if errors.As(err, &conflictErr) {
	//		c.Status(fiber.StatusConflict)
	//		return c.JSON(problems.Conflict(conflictErr.Field, conflictErr.Value, ""))
	//	}
	//
	//	// TODO: request IDs to associate with errors
	//	// TODO: setup default logger to output in a queryable format e.g JSON
	//	log.Error(err)
	//
	//	// TODO: replace err with non-descriptive "An error occurred on the server" in production
	//	return fiber.DefaultErrorHandler(c, err)
	//},
}
