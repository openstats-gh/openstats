// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package query

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const updateGameSessionUserProgress = `-- name: UpdateGameSessionUserProgress :batchone
with target_user as (
    select id from users where users.uuid = $2
), target_achievement as (
    select a.id, a.slug
    from achievement a
    join game g on a.game_id = g.id
    where a.slug = $3 and g.uuid = $4
)
insert into achievement_progress (user_id, achievement_id, progress)
select target_user.id, target_achievement.id, $1
from target_user, target_achievement
on conflict (user_id, achievement_id)
    do update set progress = excluded.progress
    where excluded.progress >= achievement_progress.progress
returning (select target_achievement.slug from target_achievement), achievement_progress.progress
`

type UpdateGameSessionUserProgressBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpdateGameSessionUserProgressParams struct {
	NewProgress     int32
	UserUuid        uuid.UUID
	AchievementSlug string
	GameUuid        uuid.UUID
}

type UpdateGameSessionUserProgressRow struct {
	Slug     string
	Progress int32
}

func (q *Queries) UpdateGameSessionUserProgress(ctx context.Context, arg []UpdateGameSessionUserProgressParams) *UpdateGameSessionUserProgressBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.NewProgress,
			a.UserUuid,
			a.AchievementSlug,
			a.GameUuid,
		}
		batch.Queue(updateGameSessionUserProgress, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateGameSessionUserProgressBatchResults{br, len(arg), false}
}

func (b *UpdateGameSessionUserProgressBatchResults) QueryRow(f func(int, UpdateGameSessionUserProgressRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i UpdateGameSessionUserProgressRow
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.Slug, &i.Progress)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *UpdateGameSessionUserProgressBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
