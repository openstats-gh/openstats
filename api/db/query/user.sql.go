// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addUser = `-- name: AddUser :one
insert into users (slug) values ($1) returning id, created_at, updated_at, uuid, slug
`

func (q *Queries) AddUser(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRow(ctx, addUser, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Uuid,
		&i.Slug,
	)
	return i, err
}

const addUserDisplayName = `-- name: AddUserDisplayName :exec
insert into user_display_name(user_id, display_name) values ($1, $2)
`

type AddUserDisplayNameParams struct {
	UserID      int32
	DisplayName string
}

func (q *Queries) AddUserDisplayName(ctx context.Context, arg AddUserDisplayNameParams) error {
	_, err := q.db.Exec(ctx, addUserDisplayName, arg.UserID, arg.DisplayName)
	return err
}

const addUserPassword = `-- name: AddUserPassword :exec
insert into user_password(user_id, encoded_hash) values ($1, $2)
`

type AddUserPasswordParams struct {
	UserID      int32
	EncodedHash string
}

func (q *Queries) AddUserPassword(ctx context.Context, arg AddUserPasswordParams) error {
	_, err := q.db.Exec(ctx, addUserPassword, arg.UserID, arg.EncodedHash)
	return err
}

const addUserSlugHistory = `-- name: AddUserSlugHistory :exec
insert into user_slug_history(user_id, slug) values ($1, $2)
`

type AddUserSlugHistoryParams struct {
	UserID int32
	Slug   string
}

func (q *Queries) AddUserSlugHistory(ctx context.Context, arg AddUserSlugHistoryParams) error {
	_, err := q.db.Exec(ctx, addUserSlugHistory, arg.UserID, arg.Slug)
	return err
}

const allUsersWithDisplayNames = `-- name: AllUsersWithDisplayNames :many
select u.id, u.created_at, u.updated_at, u.uuid, u.slug, uldn.display_name
from users u
    left outer join user_latest_display_name uldn on u.id = uldn.user_id
`

type AllUsersWithDisplayNamesRow struct {
	ID          int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Uuid        uuid.UUID
	Slug        string
	DisplayName *string
}

func (q *Queries) AllUsersWithDisplayNames(ctx context.Context) ([]AllUsersWithDisplayNamesRow, error) {
	rows, err := q.db.Query(ctx, allUsersWithDisplayNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllUsersWithDisplayNamesRow
	for rows.Next() {
		var i AllUsersWithDisplayNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Uuid,
			&i.Slug,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUser = `-- name: FindUser :one
select id, created_at, updated_at, uuid, slug from users where users.uuid = $1 limit 1
`

func (q *Queries) FindUser(ctx context.Context, argUuid uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, findUser, argUuid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Uuid,
		&i.Slug,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
select id, created_at, updated_at, uuid, slug from users where users.id = $1 limit 1
`

func (q *Queries) FindUserById(ctx context.Context, userID int32) (User, error) {
	row := q.db.QueryRow(ctx, findUserById, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Uuid,
		&i.Slug,
	)
	return i, err
}

const findUserBySlug = `-- name: FindUserBySlug :one
select id, created_at, updated_at, uuid, slug from users where slug = $1 limit 1
`

func (q *Queries) FindUserBySlug(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRow(ctx, findUserBySlug, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Uuid,
		&i.Slug,
	)
	return i, err
}

const findUserBySlugWithPassword = `-- name: FindUserBySlugWithPassword :one
select u.id, u.created_at, u.updated_at, u.uuid, u.slug, up.encoded_hash
from users u
     join user_password up on u.id = up.user_id
where u.slug = $1
limit 1
`

type FindUserBySlugWithPasswordRow struct {
	ID          int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Uuid        uuid.UUID
	Slug        string
	EncodedHash string
}

func (q *Queries) FindUserBySlugWithPassword(ctx context.Context, slug string) (FindUserBySlugWithPasswordRow, error) {
	row := q.db.QueryRow(ctx, findUserBySlugWithPassword, slug)
	var i FindUserBySlugWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Uuid,
		&i.Slug,
		&i.EncodedHash,
	)
	return i, err
}

const getUserDevelopers = `-- name: GetUserDevelopers :many
select d.slug, d.created_at, dm.created_at as joined_at
from developer_member dm
     join developer d on dm.developer_id = d.id
where dm.user_id = $1
`

type GetUserDevelopersRow struct {
	Slug      string
	CreatedAt time.Time
	JoinedAt  time.Time
}

func (q *Queries) GetUserDevelopers(ctx context.Context, userID int32) ([]GetUserDevelopersRow, error) {
	rows, err := q.db.Query(ctx, getUserDevelopers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDevelopersRow
	for rows.Next() {
		var i GetUserDevelopersRow
		if err := rows.Scan(&i.Slug, &i.CreatedAt, &i.JoinedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDisplayNames = `-- name: GetUserDisplayNames :many
select id, created_at, user_id, display_name
from user_display_name
where user_id = $1
`

func (q *Queries) GetUserDisplayNames(ctx context.Context, userID int32) ([]UserDisplayName, error) {
	rows, err := q.db.Query(ctx, getUserDisplayNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDisplayName
	for rows.Next() {
		var i UserDisplayName
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UserID,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestDisplayName = `-- name: GetUserLatestDisplayName :one
select id, created_at, user_id, display_name
from user_display_name udn
where udn.user_id = $1
order by udn.created_at desc
limit 1
`

func (q *Queries) GetUserLatestDisplayName(ctx context.Context, userID int32) (UserDisplayName, error) {
	row := q.db.QueryRow(ctx, getUserLatestDisplayName, userID)
	var i UserDisplayName
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UserID,
		&i.DisplayName,
	)
	return i, err
}

const getUserPassword = `-- name: GetUserPassword :one
select id, created_at, updated_at, user_id, encoded_hash from user_password where user_id = $1
`

func (q *Queries) GetUserPassword(ctx context.Context, userID int32) (UserPassword, error) {
	row := q.db.QueryRow(ctx, getUserPassword, userID)
	var i UserPassword
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.EncodedHash,
	)
	return i, err
}

const getUserSessionProfile = `-- name: GetUserSessionProfile :one
select
    u.uuid,
    u.slug,
    coalesce(uldn.display_name, ''),
    u.created_at,
    ua.uuid as avatar_uuid,
    ua.blurhash as avatar_blurhash
from users u
     left outer join user_latest_display_name uldn on u.id = uldn.user_id
     left outer join user_avatar ua on u.id = ua.user_id
where u.uuid = $1
limit 1
`

type GetUserSessionProfileRow struct {
	Uuid           uuid.UUID
	Slug           string
	DisplayName    string
	CreatedAt      time.Time
	AvatarUuid     uuid.NullUUID
	AvatarBlurhash *string
}

func (q *Queries) GetUserSessionProfile(ctx context.Context, userUuid uuid.UUID) (GetUserSessionProfileRow, error) {
	row := q.db.QueryRow(ctx, getUserSessionProfile, userUuid)
	var i GetUserSessionProfileRow
	err := row.Scan(
		&i.Uuid,
		&i.Slug,
		&i.DisplayName,
		&i.CreatedAt,
		&i.AvatarUuid,
		&i.AvatarBlurhash,
	)
	return i, err
}

const getUserUuid = `-- name: GetUserUuid :one
select uuid from users where slug = $1 limit 1
`

func (q *Queries) GetUserUuid(ctx context.Context, slug string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getUserUuid, slug)
	var uuid uuid.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getUserWithName = `-- name: GetUserWithName :one
select u.uuid, u.created_at, u.slug, coalesce(uldn.display_name, '')
from users u
    left outer join user_latest_display_name uldn on u.id = uldn.user_id
where u.uuid = $1
limit 1
`

type GetUserWithNameRow struct {
	Uuid        uuid.UUID
	CreatedAt   time.Time
	Slug        string
	DisplayName string
}

func (q *Queries) GetUserWithName(ctx context.Context, userUuid uuid.UUID) (GetUserWithNameRow, error) {
	row := q.db.QueryRow(ctx, getUserWithName, userUuid)
	var i GetUserWithNameRow
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.Slug,
		&i.DisplayName,
	)
	return i, err
}

const replacePassword = `-- name: ReplacePassword :exec
update user_password
    set encoded_hash = $1
where user_id = $2
`

type ReplacePasswordParams struct {
	EncodedHash string
	UserID      int32
}

func (q *Queries) ReplacePassword(ctx context.Context, arg ReplacePasswordParams) error {
	_, err := q.db.Exec(ctx, replacePassword, arg.EncodedHash, arg.UserID)
	return err
}

const updateSessionProfile = `-- name: UpdateSessionProfile :exec
with target_user as (
    select u1.id, u1.slug as old_slug, uldn.display_name as latest_display_name
    from users u1
         left outer join user_latest_display_name uldn on u1.id = uldn.user_id
    where u1.uuid = $2
), _ as (
    update users u2
    set slug = cast($3 as text)
    from target_user
    where u2.id = target_user.id and cast($3 as text) is not null and cast($3 as text) != target_user.old_slug
)
insert into user_display_name (user_id, display_name)
select target_user.id, cast($1 as text)
from target_user
where cast($1 as text) is not null and cast($1 as text) != target_user.latest_display_name
`

type UpdateSessionProfileParams struct {
	NewDisplayName *string
	Uuid           uuid.UUID
	NewSlug        *string
}

func (q *Queries) UpdateSessionProfile(ctx context.Context, arg UpdateSessionProfileParams) error {
	_, err := q.db.Exec(ctx, updateSessionProfile, arg.NewDisplayName, arg.Uuid, arg.NewSlug)
	return err
}
