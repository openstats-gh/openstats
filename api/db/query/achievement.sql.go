// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: achievement.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const findAchievementBySlug = `-- name: FindAchievementBySlug :one
select a.id, a.created_at, a.updated_at, a.game_id, a.slug, a.name, a.description, a.progress_requirement
from achievement a
     join game g on a.game_id = g.id
where a.slug = $1
  and g.uuid = $2
limit 1
`

type FindAchievementBySlugParams struct {
	AchievementSlug string
	GameUuid        uuid.UUID
}

func (q *Queries) FindAchievementBySlug(ctx context.Context, arg FindAchievementBySlugParams) (Achievement, error) {
	row := q.db.QueryRow(ctx, findAchievementBySlug, arg.AchievementSlug, arg.GameUuid)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GameID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.ProgressRequirement,
	)
	return i, err
}

const upsertAchievement = `-- name: UpsertAchievement :one
insert into achievement (game_id, slug, name, description, progress_requirement)
values ($1, $2, $3, $4, $5)
on conflict(game_id, slug)
    do update set name=excluded.name,
                  description=excluded.description,
                  progress_requirement=excluded.progress_requirement
returning case when achievement.created_at == achievement.updated_at then true else false end as upsert_was_insert
`

type UpsertAchievementParams struct {
	GameID              int32
	Slug                string
	Name                string
	Description         string
	ProgressRequirement int32
}

func (q *Queries) UpsertAchievement(ctx context.Context, arg UpsertAchievementParams) (bool, error) {
	row := q.db.QueryRow(ctx, upsertAchievement,
		arg.GameID,
		arg.Slug,
		arg.Name,
		arg.Description,
		arg.ProgressRequirement,
	)
	var upsert_was_insert bool
	err := row.Scan(&upsert_was_insert)
	return upsert_was_insert, err
}
